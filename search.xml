<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[$C++$高精度模板]]></title>
    <url>%2F2019%2F02%2F06%2FC-%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123struct bign&#123; int d[maxn], len; void clean() &#123; while(len &gt; 1 &amp;&amp; !d[len-1]) len--; &#125; bign() &#123; memset(d, 0, sizeof(d)); len = 1; &#125; bign(int num) &#123; *this = num; &#125; bign(char* num) &#123; *this = num; &#125; bign operator = (const char* num)&#123; memset(d, 0, sizeof(d)); len = strlen(num); for(int i = 0; i &lt; len; i++) d[i] = num[len-1-i] - '0'; clean(); return *this; &#125; bign operator = (int num)&#123; char s[20]; sprintf(s, "%d", num); *this = s; return *this; &#125; bign operator + (const bign&amp; b)&#123; bign c = *this; int i; for (i = 0; i &lt; b.len; i++)&#123; c.d[i] += b.d[i]; if (c.d[i] &gt; 9) c.d[i]%=10, c.d[i+1]++; &#125; while (c.d[i] &gt; 9) c.d[i++]%=10, c.d[i]++; c.len = max(len, b.len); if (c.d[i] &amp;&amp; c.len &lt;= i) c.len = i+1; return c; &#125; bign operator - (const bign&amp; b)&#123; bign c = *this; int i; for (i = 0; i &lt; b.len; i++)&#123; c.d[i] -= b.d[i]; if (c.d[i] &lt; 0) c.d[i]+=10, c.d[i+1]--; &#125; while (c.d[i] &lt; 0) c.d[i++]+=10, c.d[i]--; c.clean(); return c; &#125; bign operator * (const bign&amp; b)const&#123; int i, j; bign c; c.len = len + b.len; for(j = 0; j &lt; b.len; j++) for(i = 0; i &lt; len; i++) c.d[i+j] += d[i] * b.d[j]; for(i = 0; i &lt; c.len-1; i++) c.d[i+1] += c.d[i]/10, c.d[i] %= 10; c.clean(); return c; &#125; bign operator / (const bign&amp; b) &#123; int i, j; bign c = *this, a = 0; for (i = len - 1; i &gt;= 0; i--) &#123; a = a*10 + d[i]; for (j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; c.d[i] = j; a = a - b*j; &#125; c.clean(); return c; &#125; bign operator % (const bign&amp; b) &#123; int i, j; bign a = 0; for(i = len - 1; i &gt;= 0; i--) &#123; a = a*10 + d[i]; for(j = 0; j &lt; 10; j++) if (a &lt; b*(j+1)) break; a = a - b*j; &#125; return a; &#125; bign operator += (const bign&amp; b) &#123; *this = *this + b; return *this; &#125; bool operator &lt;(const bign&amp; b) const &#123; if(len != b.len) return len &lt; b.len; for(int i = len-1; i &gt;= 0; i--) if(d[i] != b.d[i]) return d[i] &lt; b.d[i]; return false; &#125; bool operator &gt;(const bign&amp; b) const &#123; return b &lt; *this; &#125; bool operator&lt;=(const bign&amp; b) const &#123; return !(b &lt; *this); &#125; bool operator&gt;=(const bign&amp; b) const &#123; return !(*this &lt; b); &#125; bool operator!=(const bign&amp; b) const &#123; return b &lt; *this || *this &lt; b; &#125; bool operator==(const bign&amp; b) const &#123; return !(b &lt; *this) &amp;&amp; !(b &gt; *this); &#125; string str() const &#123; char s[maxn]=&#123;&#125;; for(int i = 0; i &lt; len; i++) s[len-1-i] = d[i]+'0'; return s; &#125;&#125;;istream&amp; operator &gt;&gt; (istream&amp; in, bign&amp; x) &#123; string s; in &gt;&gt; s; x = s.c_str(); return in;&#125;ostream&amp; operator &lt;&lt; (ostream&amp; out, const bign&amp; x) &#123; out &lt;&lt; x.str(); return out;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[P1923 球形空间产生器]]></title>
    <url>%2F2019%2F02%2F05%2FP1923-%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。 输入格式第一行是一个整数n。 接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。 输出格式有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后3位。 数据保证有解。你的答案必须和标准输出一模一样才能够得分。 样例输入123420.0 0.0-1.0 1.01.0 0.0 样例输出10.500 1.500 数据规模与约定对于40%的数据，$1&lt;=n&lt;=3$。 对于100%的数据，$1&lt;=n&lt;=10$。 1、 球心：到球面上任意一点距离都相等的点。 2、 距离：设两个n为空间上的点A, B的坐标为$(a_1,a_2,…,a_n),(b_1,b_2,…,b_n)，则AB的距离定义为： $dist=sqrt((a_1−b_1)^2+(a_2−b_2)^2+…+(a_n−b_n)^2)$ 数据中所有数据绝对值小于 10000 。 因为是一个球，所以每个点到球心的距离都相等， 我们设这个半径为R，球心坐标为$O(x_1,x_2,….,x_n)$; 那么对于每一个点$P(ai1,ai2,…,ain)$：我们易得 $sqrt ( ( ai1 - x1 ) ^ 2 + ( ai2 - x2 ) ^ 2 + … + ( ain - xn ) ^2 ) = R$; 考虑构造方程组 将上式两侧平方再展开，得 $-2 ( ai1 x1 + ai2 x2 + … + ain * xn )+( ai1 ^ 2 + ai2 ^ 2 + … + ain ^ 2 )+( x1 ^ 2 + x2 ^ 2 + … + xn ^ 2 )$ = $R ^ 2$; 给出n+1个点，n个点就可以构造该方程组，那多给的一个点是用来（设选第一个点为这个点） 消掉重复出现的部分$( x1 ^ 2 + x2 ^ 2 + … + xn ^ 2 )$和$R ^ 2$， 即令其他所有的点的方程都减掉多的一个点的方程，整理得到其他方程格式为： $2 ( ai1 x1 + ai2 x2 + … + ain * xn )$ =$ ( ai1 ^ 2 + ai2 ^ 2 + … + ain ^ 2 ) - ( a11 ^ 2 + a12 ^ 2 + … + a1n ^ 2 ) - 2 ( a11 x1 + a12 x2 + … + a1n * xn ) $; 右侧是常数，左侧展开就是一个愉快的高斯消元方程组. Code… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;const double eps=1e-8;const int maxn=101;double det;inline int solve(double a[][maxn],bool l[],double ans[],const int &amp;n,const int &amp;m)&#123; int res=0,r=0; for(int i=0;i&lt;n;++i) l[i]=false; for(int i=0;i&lt;n;++i)&#123; for(int j=r;j&lt;m;++j) if(fabs(a[j][i])&gt;eps)&#123; for(int k=i;k&lt;=n;++k) swap(a[j][k],a[r][k]); break; &#125; if(fabs(a[r][i])&lt;eps)&#123; ++res; continue; &#125; for(int j=0;j&lt;m;++j) if(j!=r &amp;&amp; fabs(a[j][i])&gt;eps)&#123; double tmp=a[j][i]/a[r][i]; for(int k=i;k&lt;=n;++k) a[j][k]-=tmp*a[r][k]; &#125; l[i]=true,++r; &#125; det=1; for(int i=0;i&lt;n;++i) det*=a[i][i]; //检查是否无解 for(int i=n-res;i&lt;m;++i)&#123; if(fabs(a[i][n])&gt;eps) return -1; &#125; for(int i=0;i&lt;n;++i)&#123; if(l[i])//不是自由变元 for(int j=0;j&lt;n;++j) if(fabs(a[j][i])&gt;eps) ans[i]=a[j][n]/a[j][i]; &#125; return res;//返回自由变元数&#125;int main() &#123; double a[maxn][maxn]; bool l[maxn]; double ans[maxn]; double arr[maxn]; double brr[maxn]; int n,m,res; memset(a,0,sizeof(a)); scanf("%d",&amp;n); m=n; for(int i=0;i&lt;n;++i) scanf("%lf",&amp;arr[i]); for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;n;++j) scanf("%lf",&amp;brr[j]); for(int j=0;j&lt;n;++j) a[i][j]=2*(brr[j]-arr[j]); for(int j=0;j&lt;n;++j) a[i][n]+=(brr[j]*brr[j]-arr[j]*arr[j]); for(int j=0;j&lt;n;++j) arr[j]=brr[j]; &#125; res=solve(a,l,ans,n,m); for(int i=0;i&lt;n;++i) if(i==n-1) printf("%.3lf\n",ans[i]); else printf("%.3lf ",ans[i]); return 0;&#125; 自己做的第一道线代题。]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[APIO2015]八邻旁之桥]]></title>
    <url>%2F2019%2F02%2F01%2FAPIO2015-%E5%85%AB%E9%82%BB%E6%97%81%E4%B9%8B%E6%A1%A5%2F</url>
    <content type="text"><![CDATA[这道题我也想了一周了。 家和公司在同一侧 直接预处理 $k=1$时 实际上就是求区间中位数 在数轴上任意取一点$x$, $\sum abs(a-$a_2$)$ 那么我们将所有家和办公室按照坐标排序,桥的位置肯定就在中间两个端点的位置之间 把所有家和办公室的坐标丢进一棵Splay中,平分 统计出左边的sum和右边的sum,左边的sz和右边的sz 应该能得22分 $k=2$时 每个人的上班路线一定会选择距离$$\frac{(a+b)}{2}$最近的那座桥走 把所有的节点全部插入一棵Splay中去 然后一对一对的从旧的Splay中丢到另一棵Splay中去,一边统计 应该能得100分，但是我被卡常了 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define _min(a,b) a&lt;b?a:b#define ll long long#define which(x) (ch[fa[x]][1]==x)using namespace std;/*Namespace's template*/template&lt;class type&gt;void cmax(type &amp;a, type b)&#123;a = a &lt; b ? b : a;&#125;template&lt;class type&gt;void cmin(type &amp;a, type b)&#123;a = a &gt; b ? a : b;&#125;template&lt;class type&gt;type _abs(type a)&#123;return a &lt; 0 ? -a : a;&#125;template&lt;class type&gt;type _gcd(type a, type b)&#123;return (!b) ? a : gcd(b, a % b);&#125;template&lt;class type&gt;type _mod(type a, type p)&#123;if(a &gt;= 0 &amp;&amp; a &lt; p)return a;a %= p;if(a &lt; 0)a += p;return a;&#125;template&lt;class type&gt;type _qpow(type a, type b, type p)&#123;type ans = 1;for(; b; b &gt;&gt;= 1, a = _mod(a * a, p))if(b &amp; 1)ans = _mod(ans * a, p);return ans;&#125;/* end template*/const int inf = 1e9 + 10, N = 110000;int K, n, cnt;ll ans, fin;char s1[11], s2[11];struct node &#123; int x, y; node() &#123;&#125; node(int x,int y) : x(x), y(y) &#123;&#125; friend bool operator &lt; (const node &amp;r1, const node &amp;r2) &#123; return r1.x + r1.y &lt; r2.x + r2.y; &#125;&#125;a[N];struct Splay &#123; int cnt, root; int size[N &lt;&lt; 1], ch[N &lt;&lt; 1][2], fa[N &lt;&lt; 1], val[N &lt;&lt; 1], num[N &lt;&lt; 1]; ll sl[N &lt;&lt; 1], sr[N &lt;&lt; 1]; void pushup(int x) &#123; sl[x] = sl[ch[x][0]] + sl[ch[x][1]] + (ll)num[x] * (inf + val[x]); sr[x] = sr[ch[x][0]] + sr[ch[x][1]] + (ll)num[x] * (inf - val[x]); size[x] = size[ch[x][0]] + size[ch[x][1]] + num[x]; &#125; Splay() &#123; cnt = 2; root = 1; ch[1][0] = 2; fa[2] = 1; val[2] = -inf; val[1] = inf; num[1] = num[2] = 1; pushup(2); pushup(1); &#125; void rotate(int x) &#123; int y = fa[x], k = which(x); ch[y][k] = ch[x][k ^ 1]; ch[x][k ^ 1] = y; ch[fa[y]][which(y)] = x; fa[x] = fa[y]; fa[y] = x; fa[ch[y][k]] = y; pushup(y); pushup(x); &#125; void splay(int x,int tar) &#123; while(fa[x] != tar) &#123; int y = fa[x]; if(fa[y] == tar) rotate(x); else &#123; if(which(x) ^ which(y)) rotate(x); else rotate(y); rotate(x); &#125; &#125; if(!tar) root = x; &#125; int find_val(int x, int v) &#123; if(val[x] == v) return x; if(v &lt; val[x]) return find_val(ch[x][0], v); return find_val(ch[x][1], v); &#125; int find_kth(int x, int K) &#123; if(K &gt; size[ch[x][0]] &amp;&amp; size[ch[x][0]] + num[x] &gt;= K) return x; if(size[ch[x][0]] &gt;= K) return find_kth(ch[x][0], K); return find_kth(ch[x][1], K - size[ch[x][0]] - num[x]); &#125; void up(int x) &#123; if(!x) return; pushup(x); up(fa[x]); &#125; void insert(int v) &#123; int x = root; while(1) &#123; if(val[x] == v) &#123; num[x]++; up(x); break; &#125; if(v &lt; val[x]) &#123; if(!ch[x][0]) &#123; ch[x][0] = ++cnt; fa[cnt] = x; num[cnt] = size[cnt] = 1; val[cnt] = v; up(cnt); break; &#125; x = ch[x][0]; &#125; else &#123; if(!ch[x][1]) &#123; ch[x][1] = ++cnt; fa[cnt] = x; num[cnt] = size[cnt] = 1; val[cnt] = v; up(cnt); break; &#125; x = ch[x][1]; &#125; &#125; splay(x, 0); &#125; void del(int v) &#123; int x = find_val(root, v); num[x]--; splay(x, 0); &#125; ll query() &#123; int x = find_kth(root, size[root] &gt;&gt; 1); splay(x, 0); return sr[ch[x][0]] - (ll)(inf - val[x]) * size[ch[x][0]] + sl[ch[x][1]] - (ll)(val[x] + inf) * size[ch[x][1]] - (val[x] + inf) - (inf - val[x]); &#125;&#125;tr1, tr2;inline int read() &#123; #define in(n) n=read() register int x = 0; register char ch = getchar(); for(; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for(; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return x;&#125;int main() &#123; in(K), in(n); for(int i = 1, x1, x2; i &lt;= n; i++) &#123; scanf("%s", &amp;s1), in(x1), scanf("%s", s2), in(x2); if(s1[0] == s2[0]) ans += abs(x1 - x2); else a[++cnt] = node(x1, x2), ans++; &#125; sort(a + 1, a + 1 + cnt); fin = 1ll &lt;&lt; 60; for(int i = 1; i &lt;= cnt; i++) &#123; tr2.insert(a[i].x); tr2.insert(a[i].y); &#125; fin = _min(fin, tr1.query() + tr2.query()); if(K == 1) return printf("%lld\n",fin+ans),0; for(int i = 1; i &lt;= cnt; i++) &#123; tr2.del(a[i].x); tr2.del(a[i].y); tr1.insert(a[i].x); tr1.insert(a[i].y); fin = _min(fin, tr1.query() + tr2.query()); &#125; printf("%lld\n", ans + fin); return 0;&#125; 线段树做法你们就自己想吧。。。]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1. 栈 什么是栈？ 栈是限定仅在表头进行插入和删除操作的线性表。栈分为顺序栈和链式栈。 栈的实现 顺序栈 12345678910111213int stack[100], sz = 0;void push(int x) &#123;//入栈 stack[++sz] = x;&#125;void pop() &#123;//出栈 sz--;&#125;int top() &#123;//返回栈顶元素 return stack[sz];&#125;bool empty() &#123;//判断栈是否为空 return sz &gt;= 0 ? true : false;&#125; 链式栈 123456789101112131415161718192021222324252627282930313233343536373839//链式栈只会写一点class list&#123;public: list *head; list *tail; list *next; int num; list()&#123; head=tail=next=NULL; &#125; virtual void push(int x)=0; virtual int pop()=0;&#125;;class stack:public list&#123;public: void push(int x); int pop();&#125;;void stack::push(int x)&#123; list *noww; noww=new stack; if(!noww) return ; noww-&gt;num=x; if(head) noww-&gt;next=head; head=noww; if(!tail) tail=head;&#125;int stack::pop()&#123; int x; list *p; if(!head) return 0; x=head-&gt;num; p=head; head=head-&gt;next; delete p; return x;&#125; 2. 队列 什么是队列？ 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。 队列的实现 12345678910111213141516int queue[100], head = 0, tail = 0;void push(int x) &#123; queue[++tail] = x;&#125;void pop() &#123; head++;&#125;int front() &#123; return queue[head];&#125;int size() &#123; return tail - head;&#125;bool empty() &#123; return head &gt; tail ? true : false;&#125; 实际上队列也可以用链表实现，这里不再赘述。 3. STL实现栈和队列1234567891011121314151617//栈常用操作#include &lt;stack&gt;stack &lt;int&gt; s;s.push(1);s.pop();s.top();s.empty();s.size();//队列常用操作#include &lt;queue&gt;queue &lt;int&gt; q;q.push(1);q.pop();q.front();q.back();q.empty();q.size(); $\color{gray}{\mathcal{By}}$ $\color{gray}{\mathfrak{NULL}}$]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆和二叉树]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%A0%86%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2^k-1个叶子节点，至多有2^k-1个节点。 一般二叉树性质 在非空二叉树的i层上，至多有2^i-1个节点(i&gt;=1)。 在深度为K的二叉树上最多有2^k-1个结点（k&gt;=1)。 对于任何一棵非空的二叉树,如果叶节点个数为n0，度数为2的节点个数为n2，则有: n0 = n2 + 1 完全二叉树性质 具有n的结点的完全二叉树的深度为log2n+1. 如果有一颗有n个节点的完全二叉树的节点按层次序编号，对任一层的节点i（1&lt;=i&lt;=n）有 1.如果i=1，则节点是二叉树的根，无双亲，如果i&gt;1，则其双亲节点为[i/2]，向下取整 2.如果2i&gt;n那么节点i没有左孩子，否则其左孩子为2i 3.如果2i+1&gt;n那么节点没有右孩子，否则右孩子为2i+1 二叉树遍历 前序遍历 先访问根结点，再先序遍历左子树，最后再先序遍历右子树即根—左—右。 1234567void PreOrderTraverse(BiTree t) &#123; if(t != NULL) &#123; printf("%c ", t-&gt;data); PreOrderTraverse(t -&gt; lchild); PreOrderTraverse(t -&gt; rchild); &#125;&#125; 中序遍历 先中序遍历左子树，然后再访问根结点，最后再中序遍历右子树即左—根—右。 1234567void InOrderTraverse(BiTree t) &#123; if(t != NULL) &#123; InOrderTraverse(t -&gt; lchild); printf("%c ", t-&gt;data); InOrderTraverse(t -&gt; rchild); &#125; &#125; 后序遍历 先后序遍历左子树，然后再后序遍历右子树，最后再访问根结点即左—右—根。 1234567void PostOrderTraverse(BiTree t) &#123; if(t != NULL) &#123; PostOrderTraverse(t -&gt; lchild); PostOrderTraverse(t -&gt; rchild); printf("%c ", t-&gt;data); &#125;&#125; 建树 1234567891011121314151617181920212223typedef struct node &#123; struct node *lchild; struct node *rchild; char data; &#125;BiTreeNode, *BiTree;void createBiTree(BiTree &amp;T, char array[]) &#123; char c; c = array[N]; N++; if('#' == c) T = NULL; else &#123; if(T == NULL) return ; else &#123; T = new BiTreeNode; T -&gt; data = c; createBiTree(T -&gt; lchild, array); createBiTree(T-&gt;rchild, array); &#125; &#125;&#125; 例题 YZOJ P1196 Postorder Traversal 大体思路：因为后序遍历的最后一个字母就是根结点，在中序遍历中根结点的左边就是左子树，右边就是右子树，所以可以计算出左子树的结点总数和右子树的节点总数，再用结点的总数将后序遍历中的结点分开，分开后就是两个子树的后序遍历。 代码： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;string in, after;void search(string in,string after) &#123; int len = in.size(); if(len &lt;= 0) return; char ch = after[len - 1]; cout &lt;&lt; ch; int k = in.find(ch); search(in.substr(0, k), after.substr(0, k)); search(in.substr(k + 1), after.substr(k, len - 1 - k));&#125;int main() &#123; cin &gt;&gt; in &gt;&gt; after; search(in, after); return 0;&#125; 堆是一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 堆主要的作用是用来实现优先队列。 堆分为大根堆和小根堆，下面用小根堆做示例。 插入操作 手写实现：123456void push(int x) &#123;//swap是交换两个数的值 q[++sz] = x; int pos = sz; while(pos &gt; 1 &amp;&amp; q[pos &gt;&gt; 1] &gt; q[pos]) swap(q[pos], q[pos &gt;&gt; 1]), pos = pos &gt;&gt; 1;&#125; 删除操作 手写实现:123456789101112void pop() &#123;//swap是交换两个数的值 int rt = q[sz--], pos = 1; q[pos] = rt; while(true) &#123; int lv = (pos &lt;&lt; 1) &gt; sz ? inf : q[pos &lt;&lt; 1]; int rv = (pos &lt;&lt; 1 | 1) &gt; sz ? inf : q[pos &lt;&lt; 1 | 1]; int v = min(lv, rv), nt = lv &lt; rv ? (pos &lt;&lt; 1) : (pos &lt;&lt; 1 | 1); if(q[pos] &gt; v) swap(q[pos], q[nt]), pos = nt; else break; &#125;&#125; 其他操作 手写实现： 1234567891011int top() &#123;//返回队首元素 return q[1];&#125;int size() &#123;//返回队列大小 return sz;&#125;bool empty() &#123; return sz == 0 ? true : false;&#125; STL实现优先队列12345678empty()//如果队列为空，则返回真pop()//删除对顶元素，删除第一个元素push()//加入一个元素size()//返回优先队列中拥有的元素个数top()//返回优先队列对顶元素，返回优先队列中有最高优先级的元素//在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。//需要头文件#include &lt;queue&gt; 实际上你可以去YZOJ里的AAS里有一个pb_ds库的介绍，可以实现优先队列，速度接近手写。例题 YZOJ P2704 [NOIP 2016 四校联训 Round 4]打败黑熊 大体思路：维护一个小根堆，每个守卫机关相当于向堆中加入一个数，每个审判机关相当于删除堆中最小值，直到堆中的元素个数小于上限。最后直接把堆中所有的数加起来。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//顺便演示一下pb_ds中的priority_queue#include &lt;cstdio&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;//注意要加这个头文件using namespace std;__gnu_pbds::priority_queue&lt;int,greater&lt;int&gt; &gt; q;//声明方式 int n, m;char st[6];inline int read() &#123;//快读 #define in(n) n=read() register int x = 0; register char ch = getchar(); for(; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for(; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return x;&#125;int main() &#123; in(n), in(m); for(int i = 1, t; i &lt;= n; i++) &#123; scanf("%s", &amp;st); in(t); if(st[0] == 'd') &#123; q.push(t); continue; &#125; if(t &lt;= 0) &#123; puts("Rabbit can not beat bear."); return 0; &#125; while(q.size() &gt;= t) q.pop(); &#125; int ans = 0, sz = 0; while(!q.empty()) &#123; ans += q.top(); sz++; q.pop(); &#125; if(sz &gt;= m) printf("%d\n", ans); else &#123; puts("Rabbit can not beat bear."); return 0; &#125; return 0;&#125; $\color{gray}{\mathcal{By}}$ $\color{gray}{\mathfrak{NULL}}$]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YZOJ P1299 [NOIP福建夏令营]金字塔]]></title>
    <url>%2F2018%2F11%2F17%2FYZOJ-P1299-NOIP%E7%A6%8F%E5%BB%BA%E5%A4%8F%E4%BB%A4%E8%90%A5-%E9%87%91%E5%AD%97%E5%A1%94%2F</url>
    <content type="text"><![CDATA[题目描述小X来到一个雄奇的金字塔挖宝，但是这是一座被诅咒的金字塔，小X必须马上逃离这里，否则小X就会被埋在金字塔里，但他不希望此行落空。 现在小X面前有$N+1$种财宝，每种财宝都有一个价值。第一种财宝重量为0，第二种财宝重量为1，总之第I种财宝重量为$I-1$。现在小X希望拿走$N+M$个物品，但是这$M+N$个物品总重量不能超过N。小X希望能获得最大的价值。你能帮帮他吗？ 由于金字塔跟小X一样牛，所以每种财宝无限个。 输入格式第一行两个正整数$N$，$M$ 第二行$N+1$个整数，第$I$个整数代表了第I种财宝的价值 输出格式一个数，表示最大利润。 样例输入125 34 7 2 5 -3 6 样例输出147 数据规模与约定10%满足$N$,$M&lt;=10$ 40%满足$N$,$M&lt;=100$ 100%满足$N$,$M&lt;=3000$ $abs(财宝价值)&lt;=1000$ 这就是一道背包的应用题。你们也可以学习kyz的做法（毕竟他的做法貌似比我的快，空间用的比我小），在这里讲一下我的一种做法。 这是一个比较特殊的动态规划，首先要注意到因为要取到$N+M$个，所以我们可以知道每一次至少要拿走$M+N$件0号物品，所以我们的初始化就是这样。 12for(i=0;i&lt;=n;i++) f[i]=(n+m)*a[0]; 对于这样的完全背包问题，我们需要找到一个动态规划转移方程。$f[i]$表示$i$的体积下最多得到的价值，$f[j]+a[i]-a[0]$是从j空间转移而来，所以$f[j]+a[i]-a[0]$中$-a[0]$的原因是：我们模拟出来在执行之前，全部都装满了0号物品，所以我们在转移的时候，需要取出一个0号物品，再塞进去一个$i$号物品。 1f[i+j]=max(f[j]+a[i]-a[0],f[i+j]); 代码： 1234567891011121314#include &lt;cstdio&gt;#define re register//我没用快读模板是因为有负数，所以我就用了scanfint n,m;int a[3001],f[3001]=&#123;0&#125;;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(re int i=0;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(re int i=0;i&lt;=n;i++) f[i]=(n+m)*a[0]; //初始化 for(re int i=1;i&lt;=n;i++) for(re int j=0;j&lt;=n-i;j++) f[i+j]=max(f[j]+a[i]-a[0],f[i+j]); //动态转移方程 return !printf("%d\n",f[n]);&#125; $\color{gray}{\mathfrak{End}}$]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018%2F11%2F10%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今年是我第一次参加NOIP，心情非常的激动。 去试机时，打了个a+b，之后就在玩扫雷。 比赛当天，早上在家A了一道dp题，下午去比赛。 T1：这不是一道大水题吗？ 5-10min完成。 T2：这也很水啊，一道普普通通的模拟。 15-30min完成（主要是在弄大数据） T3：考场上觉得这又是一道模拟，然而我想的太简单了。 打了个暴力。 后来知道这道正解是dp。。。 T4：没时间了，T3耗太久了。 直接输样例 预计：100+100+50+10=260 实际：70+100+10+4=184 完蛋了T1这么水的题我都没A， 只能回去搞文化课了。。。]]></content>
      <tags>
        <tag>NOIP游记</tag>
      </tags>
  </entry>
</search>
