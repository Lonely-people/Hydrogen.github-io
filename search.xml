<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[堆和二叉树]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%A0%86%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2^k-1个叶子节点，至多有2^k-1个节点。 一般二叉树性质 在非空二叉树的i层上，至多有2^i-1个节点(i&gt;=1)。 在深度为K的二叉树上最多有2^k-1个结点（k&gt;=1)。 对于任何一棵非空的二叉树,如果叶节点个数为n0，度数为2的节点个数为n2，则有: n0 = n2 + 1 完全二叉树性质 具有n的结点的完全二叉树的深度为log2n+1. 如果有一颗有n个节点的完全二叉树的节点按层次序编号，对任一层的节点i（1&lt;=i&lt;=n）有 1.如果i=1，则节点是二叉树的根，无双亲，如果i&gt;1，则其双亲节点为[i/2]，向下取整 2.如果2i&gt;n那么节点i没有左孩子，否则其左孩子为2i 3.如果2i+1&gt;n那么节点没有右孩子，否则右孩子为2i+1 二叉树遍历 前序遍历 先访问根结点，再先序遍历左子树，最后再先序遍历右子树即根—左—右。 1234567void PreOrderTraverse(BiTree t) &#123; if(t != NULL) &#123; printf("%c ", t-&gt;data); PreOrderTraverse(t -&gt; lchild); PreOrderTraverse(t -&gt; rchild); &#125;&#125; 中序遍历 先中序遍历左子树，然后再访问根结点，最后再中序遍历右子树即左—根—右。 1234567void InOrderTraverse(BiTree t) &#123; if(t != NULL) &#123; InOrderTraverse(t -&gt; lchild); printf("%c ", t-&gt;data); InOrderTraverse(t -&gt; rchild); &#125; &#125; 后序遍历 先后序遍历左子树，然后再后序遍历右子树，最后再访问根结点即左—右—根。 1234567void PostOrderTraverse(BiTree t) &#123; if(t != NULL) &#123; PostOrderTraverse(t -&gt; lchild); PostOrderTraverse(t -&gt; rchild); printf("%c ", t-&gt;data); &#125;&#125; 建树 1234567891011121314151617181920212223typedef struct node &#123; struct node *lchild; struct node *rchild; char data; &#125;BiTreeNode, *BiTree;void createBiTree(BiTree &amp;T, char array[]) &#123; char c; c = array[N]; N++; if('#' == c) T = NULL; else &#123; if(T == NULL) return ; else &#123; T = new BiTreeNode; T -&gt; data = c; createBiTree(T -&gt; lchild, array); createBiTree(T-&gt;rchild, array); &#125; &#125;&#125; 例题 YZOJ P1196 Postorder Traversal 大体思路：因为后序遍历的最后一个字母就是根结点，在中序遍历中根结点的左边就是左子树，右边就是右子树，所以可以计算出左子树的结点总数和右子树的节点总数，再用结点的总数将后序遍历中的结点分开，分开后就是两个子树的后序遍历。 代码： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;string in, after;void search(string in,string after) &#123; int len = in.size(); if(len &lt;= 0) return; char ch = after[len - 1]; cout &lt;&lt; ch; int k = in.find(ch); search(in.substr(0, k), after.substr(0, k)); search(in.substr(k + 1), after.substr(k, len - 1 - k));&#125;int main() &#123; cin &gt;&gt; in &gt;&gt; after; search(in, after); return 0;&#125; 堆是一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 堆主要的作用是用来实现优先队列。 堆分为大根堆和小根堆，下面用小根堆做示例。 插入操作 手写实现：123456void push(int x) &#123;//swap是交换两个数的值 q[++sz] = x; int pos = sz; while(pos &gt; 1 &amp;&amp; q[pos &gt;&gt; 1] &gt; q[pos]) swap(q[pos], q[pos &gt;&gt; 1]), pos = pos &gt;&gt; 1;&#125; 删除操作 手写实现:123456789101112void pop() &#123;//swap是交换两个数的值 int rt = q[sz--], pos = 1; q[pos] = rt; while(true) &#123; int lv = (pos &lt;&lt; 1) &gt; sz ? inf : q[pos &lt;&lt; 1]; int rv = (pos &lt;&lt; 1 | 1) &gt; sz ? inf : q[pos &lt;&lt; 1 | 1]; int v = min(lv, rv), nt = lv &lt; rv ? (pos &lt;&lt; 1) : (pos &lt;&lt; 1 | 1); if(q[pos] &gt; v) swap(q[pos], q[nt]), pos = nt; else break; &#125;&#125; 其他操作 手写实现： 1234567891011int top() &#123;//返回队首元素 return q[1];&#125;int size() &#123;//返回队列大小 return sz;&#125;bool empty() &#123; return sz == 0 ? true : false;&#125; STL实现优先队列12345678empty()//如果队列为空，则返回真pop()//删除对顶元素，删除第一个元素push()//加入一个元素size()//返回优先队列中拥有的元素个数top()//返回优先队列对顶元素，返回优先队列中有最高优先级的元素//在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。//需要头文件#include &lt;queue&gt; 实际上你可以去YZOJ里的AAS里有一个pb_ds库的介绍，可以实现优先队列，速度接近手写。例题 YZOJ P2704 [NOIP 2016 四校联训 Round 4]打败黑熊 大体思路：维护一个小根堆，每个守卫机关相当于向堆中加入一个数，每个审判机关相当于删除堆中最小值，直到堆中的元素个数小于上限。最后直接把堆中所有的数加起来。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//顺便演示一下pb_ds中的priority_queue#include &lt;cstdio&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;//注意要加这个头文件using namespace std;__gnu_pbds::priority_queue&lt;int,greater&lt;int&gt; &gt; q;//声明方式 int n, m;char st[6];inline int read() &#123;//快读 #define in(n) n=read() register int x = 0; register char ch = getchar(); for(; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for(; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return x;&#125;int main() &#123; in(n), in(m); for(int i = 1, t; i &lt;= n; i++) &#123; scanf("%s", &amp;st); in(t); if(st[0] == 'd') &#123; q.push(t); continue; &#125; if(t &lt;= 0) &#123; puts("Rabbit can not beat bear."); return 0; &#125; while(q.size() &gt;= t) q.pop(); &#125; int ans = 0, sz = 0; while(!q.empty()) &#123; ans += q.top(); sz++; q.pop(); &#125; if(sz &gt;= m) printf("%d\n", ans); else &#123; puts("Rabbit can not beat bear."); return 0; &#125; return 0;&#125; $\color{gray}{\mathcal{By}}$ $\color{gray}{\mathfrak{NULL}}$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F02%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
