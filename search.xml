<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ2301 [HAOI2001]Problem b]]></title>
    <url>%2F2019%2F07%2F03%2FBZOJ2301-HAOI2001-Problem-b%2F</url>
    <content type="text"><![CDATA[题目链接 求值： $\displaystyle\sum_{i=x}^{n}\sum_{j=y}^{m}[\gcd(i,j)=k]\qquad(1\leqslant T,x,y,n,m,k\leqslant 50000)$ 分析由容斥原理可将原式分成4块处理，每一块式子为 $\displaystyle\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=k]$ 化简得 $\displaystyle\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}[\gcd(i,j)=1]$ 因为当$\gcd(i,j)=1$时对答案有贡献，所以可以替换为$\varepsilon(\gcd(i,j))$，所以原式被化简为 $\displaystyle\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\varepsilon(\gcd(i,j))$ 将$\varepsilon(\gcd(i,j))$用$\text{Dirichlet}$卷积展开得 $\displaystyle\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}\sum_{d\mid\gcd(i,j)}\mu(d)$ 变换求和顺序得 $\displaystyle\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\sum_{i=1}^{\lfloor\frac{n}{k}\rfloor}d\mid i\sum_{j=1}^{\lfloor\frac{m}{k}\rfloor}d\mid j$ 容易得知$\displaystyle 1\sim\lfloor\frac{n}{k}\rfloor$中有$d$的倍数$\displaystyle\lfloor\frac{n}{kd}\rfloor$个，所以原式被化简为 $\displaystyle\sum_{d=1}^{\lfloor\frac{n}{k}\rfloor}\mu(d)\lfloor\frac{n}{kd}\rfloor\lfloor\frac{m}{kd}\rfloor$ 很明显，化简后的式子可以用数论分块解决(过程中默认$n\leqslant m$) 时间复杂度为$\displaystyle\Theta(N+T\sqrt{n})$ $Code$ 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define reg register#define MAXN 50010using namespace std;int mu[MAXN], p[MAXN];bool flag[MAXN];inline void init() &#123; // 预处理莫比乌斯函数 int tot = 0; mu[1] = 1; for(reg int i = 2, j; i &lt;= MAXN; ++i) &#123; for(!flag[i] ? p[++tot] = i, mu[i] = -1 : 1, j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= MAXN; ++j) &#123; flag[i * p[j]] = 1; if(!(i % p[j])) &#123; mu[i * p[j]] = 0; break; &#125; mu[i * p[j]] = -mu[i]; &#125; &#125; for(reg int i = 1; i &lt;= MAXN; ++i) mu[i] += mu[i - 1];&#125;int solve(int n, int m) &#123; // 数论分块 int res = 0; for(reg int i = 1, j; i &lt;= min(n, m); i = j + 1) j = min(n / (n / i), m / (m / i)), res += (mu[j] - mu[i - 1]) * (n / i) * (m / i); return res;&#125;int main() &#123; int T, a, b, c, d, k; init(); for(scanf("%d", &amp;T); T; T--) &#123; scanf("%d%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d, &amp;k); printf("%d\n", solve(b / k, d / k) - solve(b / k, (c - 1) / k) - solve((a - 1) / k, d / k) + solve((a - 1) / k, (c - 1) / k)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式全家桶]]></title>
    <url>%2F2019%2F06%2F02%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%85%A8%E5%AE%B6%E6%A1%B6%2F</url>
    <content type="text"><![CDATA[$FFT$ 1234567891011121314inline void fft(Complex * a, int type) &#123; for(register int i = 0; i &lt; limit; ++i) if(i &lt; r[i]) swap(a[i], a[r[i]]); for(register int Mid = 1; Mid &lt; limit; Mid &lt;&lt;= 1) &#123; Complex Wn(cos(Pi / Mid), type * sin(Pi / Mid)); for(register int R = Mid &lt;&lt; 1, j = 0; j &lt; limit; j += R) &#123; Complex w(1, 0); for(register int k = 0; k &lt; Mid; ++k, w = w * Wn) &#123; Complex x = a[j + k], y = w * a[j + Mid + k]; a[j + k] = x + y, a[j + Mid + k] = x - y; &#125; &#125; &#125;&#125; $NTT$ 1234567891011121314151617181920212223inline void NTT(int * a, int len, int o) &#123; for(register int i = 0, j = 0; i &lt; len; ++i) &#123; if(i &gt; j) swap(a[i], a[j]); for(register int l = len &gt;&gt; 1; (j ^= l) &lt; l; l &gt;&gt;= 1); &#125; int cnt = 0; for(register int i = 1; i &lt; len; i &lt;&lt;= 1) &#123; cnt++; for(register int j = 0; j &lt; len; j += i &lt;&lt; 1) &#123; int w = 1; for(register int k = 0; k &lt; i; ++k) &#123; int x = a[j + k] % p, y = (w * a[j + k + i]) % p; a[j + k] = (x + y) % p, a[j + k + i] = (x - y + p) % p; w = (w * Wn[cnt]) % p; &#125; &#125; &#125; if(!~ o) &#123; reverse(a + 1, a + len); int inv = qpow(len, p - 2, p); for(register int i = 0; i &lt; len; ++i) a[i] = (a[i] * inv) % p; &#125;&#125; 多项式求逆 $Description$ 给定多项式$f(x)$，求$f^{-1}(x)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#define int long longusing namespace std;const int MAXN = 1e6 + 10;const int p = 998244353;int n, m, r[MAXN], a[MAXN], b[MAXN], Wn[MAXN];int qpow(int a, int b, int MOD = p) &#123; int base = 1; while(b) &#123; if(b &amp; 1) base = (base * a) % MOD; b &gt;&gt;= 1, a = (a * a) % MOD; &#125; return base;&#125;inline void NTT(int * a, int len, int o) &#123; for(register int i = 0, j = 0; i &lt; len; ++i) &#123; if(i &gt; j) swap(a[i], a[j]); for(register int l = len &gt;&gt; 1; (j ^= l) &lt; l; l &gt;&gt;= 1); &#125; int cnt = 0; for(register int i = 1; i &lt; len; i &lt;&lt;= 1) &#123; cnt++; for(register int j = 0; j &lt; len; j += i &lt;&lt; 1) &#123; int w = 1; for(register int k = 0; k &lt; i; ++k) &#123; int x = a[j + k] % p, y = (w * a[j + k + i]) % p; a[j + k] = (x + y) % p, a[j + k + i] = (x - y + p) % p; w = (w * Wn[cnt]) % p; &#125; &#125; &#125; if(!~ o) &#123; reverse(a + 1, a + len); int inv = qpow(len, p - 2, p); for(register int i = 0; i &lt; len; ++i) a[i] = (a[i] * inv) % p; &#125;&#125;inline void Inv(int deg, int * a, int * b) &#123; static int tmp[MAXN]; if(deg == 1) b[0] = qpow(a[0], p - 2); else &#123; Inv((deg + 1) &gt;&gt; 1, a, b); int __ = 1; while(__ &lt; deg &lt;&lt; 1) __ &lt;&lt;= 1; copy(a, a + deg, tmp); fill(tmp + deg, tmp + __, 0); NTT(tmp, __, 1), NTT(b, __, 1); for(register int i = 0; i &lt; __; ++i) b[i] = (2 - b[i] * tmp[i] % p + p) % p * b[i] % p; NTT(b, __, -1); fill(b + deg, b + __, 0); &#125;&#125;inline int read() &#123; register int x = 0, ch = getchar(), f = 1; while(!isdigit(ch)) &#123; if(ch == '-') f = -1; ch = getchar(); &#125; while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return x * f;&#125;signed main() &#123; for(register int i = 0; i &lt;= 20; ++i) Wn[i] = qpow(3, (p - 1) / (1 &lt;&lt; i), p); n = read(); for(register int i = 0; i &lt; n; ++i) a[i] = read(); int limit = 1, l = 0; while(limit &lt;= n &lt;&lt; 1) limit &lt;&lt;= 1, l++; Inv(n, a, b); for(register int i = 0; i &lt; n; ++i) printf("%lld ", (b[i] + p) % p); return 0;&#125; 多项式开方 $Description$ 给定多项式$g(x)$，求$f(x)$，满足： $f^2(x)\equiv g(x) \pmod{x^{n}}$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;stdio.h&gt;#define ll long longusing namespace std;const int MAXN = 1e6 + 10;const int P = 998244353;const int inv2 = 499122177;const int G = 332748118;int r[MAXN], f[MAXN], g[MAXN], A[MAXN], B[MAXN], C[MAXN], D[MAXN];int qpow(int a, int b) &#123; int base = 1; while(b) &#123; if(b &amp; 1) base = 1ll * base * a % P; b &gt;&gt;= 1, a = 1ll * a * a % P; &#125; return (base + P) % P;&#125;inline void NTT(int * a, int n, int o) &#123; for(register int i = 0; i &lt; n; ++i) if(i &lt; r[i]) swap(a[i], a[r[i]]); for(register int Mid = 1; Mid &lt; n; Mid &lt;&lt;= 1) &#123; int cnt = qpow(o == 1 ? 3 : G, (P - 1) / (Mid &lt;&lt; 1)); for(register int j = 0; j &lt; n; j += (Mid &lt;&lt; 1)) &#123; int w = 1; for(register int k = 0; k &lt; Mid; ++k, w = 1ll * w * cnt % P) &#123; int x = a[j + k], y = 1ll * w * a[j + k + Mid] % P; a[j + k] = (x + y) % P, a[j + k + Mid] = (ll) (x - y + P) % P; &#125; &#125; &#125; if(o == 1) return; int inv = qpow(n, P - 2); for(register int i = 0; i &lt; n; ++i) a[i] = 1ll * a[i] * inv % P;&#125;inline void Inv(int * a, int * b, int n) &#123; b[0] = qpow(a[0], P - 2); int len, limit; for(len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1) &#123; limit = len &lt;&lt; 1; for(register int i = 0; i &lt; len; ++i) A[i] = a[i], B[i] = b[i]; for(register int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? len : 0); NTT(A, limit, 1), NTT(B, limit, 1); for(register int i = 0; i &lt; limit; ++i) b[i] = ((2ll - 1ll * A[i] * B[i] % P) * B[i] % P + P) % P; NTT(b, limit, -1); for(register int i = len; i &lt; limit; ++i) b[i] = 0; &#125; for(register int i = 0; i &lt; len; ++i) A[i] = B[i] = 0; for(register int i = n; i &lt; len; ++i) b[i] = 0;&#125;inline void Sqrt(int * a, int * b, int n) &#123; b[0] = 1; int * A = C, * B = D, len, limit; for(len = 1; len &lt; (n &lt;&lt; 1); len &lt;&lt;= 1) &#123; limit = len &lt;&lt; 1; for(register int i = 0; i &lt; len; ++i) A[i] = a[i]; Inv(b, B, len); for(register int i = 0; i &lt; limit; ++i) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) ? len : 0); NTT(A, limit, 1), NTT(B, limit, 1); for(register int i = 0; i &lt; limit; ++i) A[i] = 1ll * A[i] * B[i] % P; NTT(A, limit, -1); for(register int i = 0; i &lt; len; ++i) b[i] = 1ll * (b[i] + A[i]) % P * inv2 % P; for(register int i = len; i &lt; limit; ++i) b[i] = 0; &#125; for(register int i = 0; i &lt; len; ++i) A[i] = B[i] = 0; for(register int i = n; i &lt; len; ++i) b[i] = 0;&#125;inline int read() &#123; register int x = 0, ch = getchar(), f = 1; while(!isdigit(ch)) &#123; if(ch == '-') f = -1; ch = getchar(); &#125; while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar(); return x * f;&#125;int main() &#123; int n = read(); for(register int i = 0; i &lt; n; ++i) f[i] = read(); Sqrt(f, g, n); for(register int i = 0; i &lt; n; ++i) printf("%d%c", g[i], " \n" [i == n - 1]); return 0;&#125; 未完待续…]]></content>
      <tags>
        <tag>Soution</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1115 [POI2009]KAM-Pebbles]]></title>
    <url>%2F2019%2F04%2F26%2FBZOJ1115-POI2009-KAM-Pebbles%2F</url>
    <content type="text"><![CDATA[阶梯$Nim$ 对于这种游戏，必胜策略就是只要你把x颗石子从偶数层拿到奇数层，那我就把这x颗石子拿到偶数层。 若我们从$i$处取走了$x$个石子，那么下一次及以后就可以在$i+1$处多取$x$个，相当于把$i$处的$x$个石子加到了$i+1$处 ，所以可以转化成阶梯$Nim$ 不懂可以看一下https://blog.csdn.net/kk303/article/details/6692506 代码: 点击显示代码 12345678910111213141516171819#include &lt;cstdio&gt;#define N 1000int T, n, a[N+5];int main() &#123; scanf("%d", &amp;T); while(T--) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; ++i) scanf("%d", &amp;a[i]); int ans = 0; for(int i = n; i &gt;= 1; i -= 2) ans ^= (a[i]-a[i-1]); if(ans) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P3553[POI2013]INS-Inspecotr]]></title>
    <url>%2F2019%2F03%2F21%2FLuogu-P3553-POI2013-INS-Inspecotr%2F</url>
    <content type="text"><![CDATA[分析先二分答案转化成一个判定性问题，这样记录就没有先后之分了。 然后考虑什么情况会出现矛盾 两条记录是同一时刻的，但人数不同。 解决：直接特判 举个例子 小$A$在$x$时刻写过一个记录，又在$y$时刻写了一个记录，小$B$写除了他没有人了。 解决：对每个人记录一下最晚开始时间和最早结束时间当成一条线段，对于每个时间节点，算被几条线段覆盖，线段条数大于当前时间记录的人数时就是无解。 根据记录构造出一种方案，但是会超过n个人的限制的方案 解决：计算出他的最小符合条件的人数，判断是否$&lt;=n$。 code:点击显示代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#define N 100010#define inf 0x3f3f3f3fint n, m, t[N], u[N], v[N], mn[N], mx[N], tot[N], st[N], en[N];inline int read() &#123; register int x = 0; register char ch = getchar(); for (; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for (; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return x;&#125;inline void write(int num) &#123; if (num &gt; 9) write(num / 10); putchar(num % 10 ^ 48);&#125;template&lt;class type&gt;type max(type &amp;a, type &amp;b) &#123; return a &gt; b ? a : b;&#125;template&lt;class type&gt;type min(type &amp;a, type &amp;b) &#123; return a &lt; b ? a : b;&#125;bool check(int M) &#123; for (int i = 1; i &lt;= n; i++) mn[i] = inf, mx[i] = -inf; for (int i = 1; i &lt;= m; i++) tot[i] = st[i] = en[i] = 0; for (int i = 1; i &lt;= M; i++) &#123; mn[u[i]] = min(mn[u[i]], t[i]), mx[u[i]] = max(mx[u[i]], t[i]); if (tot[t[i]] and tot[t[i]] != v[i] + 1) return false; tot[t[i]] = v[i] + 1; &#125; for (int i = 1; i &lt;= n; i++) if (mx[i] != -inf) st[mn[i]]++, en[mx[i]]++; int total = 0, now = 0, done = 0, notr = 0; for (int i = 1; i &lt;= m; i++) if (tot[i]) &#123; now += st[i]; if (now &gt; tot[i]) return false; if (st[i] &lt;= notr) notr -= st[i]; else total += st[i] - notr, notr = 0; if (now + notr + done &lt; tot[i]) total += tot[i] - now - notr - done, notr = tot[i] - now - done; else &#123; if (now + notr &gt; tot[i]) notr = tot[i] - now, done = 0; else done = tot[i] - now - notr; &#125; now -= en[i]; done += en[i]; &#125; if (total &gt; n) return false; return true;&#125;int main() &#123; int T; T = read(); while (T--) &#123; n = read(), m = read(); for (int i = 1; i &lt;= m; i++) t[i] = read(), u[i] = read(), v[i] = read(); int l = 1, r = m + 1, mid; while (l &lt; r) &#123; mid = (l + r) &gt;&gt; 1; if (check(mid)) l = mid + 1; else r = mid; &#125; write(l - 1), putchar('\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu P3421[POI2005]SKO-Knights]]></title>
    <url>%2F2019%2F03%2F21%2FLuogu-P3421-POI2005-SKO-Knights%2F</url>
    <content type="text"><![CDATA[因为LATEX挂了，所以重新交一遍 分析 我们设原向量为$(a_1, b_1)$,$(a_2, b_2)$。设新向量为$(a_3, b_3)$，$(0, a_4)$ $\therefore$ $a_3=gcd(a_1,a_2)$ $\therefore$ $a_1x + a_2y = a_3$ $\therefore$ $a_1x + a_2y = gcd(a_1,a_2)$ $b_1x + b_2y = b_3$ $\begin{cases}a_1x + a_2y = 0\b_1x + b_2y = b_4\end{cases}$ $\therefore$ $-y = \dfrac{a_1x}{a_2}$ $\because$ $-y$是整数 $\therefore$ $a_2|a_1x$ 即$\dfrac{a_2}{gcd(a_1,a_2)}|\dfrac{a_1}{gcd(a_1,a_2)x}$ 又$\therefore$ $\dfrac{a_2}{gcd(a_1,a_2)}|\dfrac{a_1}{gcd(a_1,a_2)x}$互质 $\therefore$ $\dfrac{a_2}{gcd(a_1,a_2)}|x$ 设$x=\dfrac{a_2}{gcd(a_1,a_2)}$ $\therefore$ $-\dfrac{a_1}{gcd(a_1,a_2)}$ $\therefore$ $b_4 = \dfrac{|b_1a_2-b_2a_1|}{gcd(a_1,a_2)}$ 我们只需要不断的将向量转变到y轴上使得最终至多一个向量不再y轴上就行了。 代码: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;int a[510], b[510];template&lt;class type&gt;type _gcd(type __, type ___) &#123; return (!___) ? __ : _gcd(___, __ % ___);&#125;template&lt;class type&gt;type _abs(type __) &#123; return __ &lt; 0 ? -__ : __;&#125;inline void exgcd(int a, int b, int &amp;x, int &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return; &#125; exgcd(b, a%b, x, y); int z = x; x = y; y = z - (a / b)*y;&#125;int main() &#123; int n, m, x, y; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;a[i], &amp;b[i]); int a1, b1, a2, b2; if (!a[1]) &#123; a1 = a[2]; b1 = b[2]; b2 = b[1]; &#125; else if (!a[2]) &#123; a1 = a[1]; b1 = b[1]; b2 = b[2]; &#125; else &#123; a1 = _gcd(a[1], a[2]); exgcd(a[1] / a1, a[2] / a1, x, y); b1 = b[1] * x + b[2] * y; b2 = _abs(b[1] * a[2] - b[2] * a[1]) / a1; &#125; for (int i = 3; i &lt;= n; i++) &#123; if (!a1) &#123; a1 = a[i]; b2 = _gcd(b2, b1); b1 = b[i]; &#125; else if (!a[i])b2 = _gcd(b2, b[i]); else &#123; int be = a1, be2 = b1; a1 = _gcd(a1, a[i]); exgcd(be / a1, a[i] / a1, x, y); b1 = b1 * x + b[i] * y; b2 = _gcd(b2, _abs(be2*a[i] - b[i] * be) / a1); &#125; &#125; printf("%d %d\n", a1, b1); putchar('0'), putchar(' '); printf("%d\n", b2); return 0;&#125; 码风较丑，见谅]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF368B Sereja and Suffixes]]></title>
    <url>%2F2019%2F03%2F05%2FCF368B-Sereja-and-Suffixes%2F</url>
    <content type="text"><![CDATA[看到好像没人发树状数组的题解，于是就发一篇 题目大意给出一个长度为$n$的序列$a$,给出$m$个查询$l$,对于每个查询输出$[l,n]$的区间内不同数的个数。 分析： 将查询按照$l$的大小排序，从大到小的遍历，每次将$&gt;=$当前$l$的位置的$a[i]$全部加入树状数组，让树状数组记录每个数是否出现过，每次的答案就是查询树状数组的总和。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;algorithm&gt;const int MAX = 100010;#define lowbit(x) x &amp; -xusing namespace std;typedef pair&lt;int, int&gt; pa;int n, m, ans[MAX], a[MAX], c[MAX];pa l[MAX];const int lim = 1e5 + 1;//templatetemplate&lt;class type&gt;type _max(type _, type __) &#123; return _ &gt; __ ? _ : __; &#125;template&lt;class type&gt;type _min(type _, type __) &#123; return _ &lt; __ ? _ : __; &#125;template&lt;class type&gt;type _abs(type __) &#123; return __ &lt; 0 ? -__ : __; &#125;template&lt;class type&gt;type _gcd(type __, type ___) &#123; return (!___) ? __ : gcd(___, __ % ___); &#125;template&lt;class type&gt;type _mod(type __, type ____) &#123; if (__ &gt;= 0 &amp;&amp; __ &lt; ____)return __; __ %= ____; if (__ &lt; 0)__ += ____; return __; &#125;template&lt;class type&gt;type _qpow(type __, type ___, type ____) &#123; type ans = 1; for (; ___; ___ &gt;&gt;= 1, __ = _mod(__ * __, ____))if (___ &amp; 1)ans = _mod(ans * __, ____); return ans; &#125;//char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;//inline int getc() &#123;// return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++;//&#125;inline int r() &#123; register int x = 0; register char ch = getchar(); for (; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for (; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return x;&#125;inline double r_db() &#123; double s = 0.0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') &#123; if (c == '-') f = -1; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; s = s * 10 + (c ^ 48); c = getchar(); &#125; if (c == '.') &#123; int k = 10; c = getchar(); while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; s += (double)(c ^ 48) / k; k *= 10; c = getchar(); &#125; &#125; return s;&#125;//以上的template可以忽略void add(int x) &#123; while (x &lt;= lim) &#123; c[x]++; x += lowbit(x); &#125;&#125;int sum(int x) &#123; int ret = 0; while (x) &#123; ret += c[x]; x -= lowbit(x); &#125; return ret;&#125;int main() &#123; while (~scanf("%d%d", &amp;n, &amp;m)) &#123; for (int i = 0; i &lt; n; i++) a[i] = r(); for (int i = 0; i &lt; m; i++) &#123; l[i].first = r(); l[i].first--; l[i].second = i; &#125; sort(l, l + m); int j = n - 1; for (int i = m - 1; i &gt;= 0; i--) &#123; while (j &gt;= l[i].first) &#123; if (sum(a[j]) - sum(a[j] - 1) == 0) add(a[j]); j--; &#125; ans[l[i].second] = sum(1e5); &#125; for (int i = 0; i &lt; m; i++) printf("%d\n", ans[i]); &#125;&#125; 希望你们不要$ctrl+c$ $ctrl+v$]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YZOJ P3643 题解]]></title>
    <url>%2F2019%2F02%2F20%2FYZOJ-P3643-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[题面：https://fzyzoi.tk/OnlineJudge/problem_show.php?id=3643 主要思路就是建一棵树，然后根据三种遍历的定义写一个函数，再分别输出遍历结果。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* 3 2 3 0 0 0 0*//* 1 2 3 2 1 3 2 3 1*/#include &lt;cstdio&gt;#define maxn 100000int n/*结点数*/, l[maxn + 10]/*左儿子*/, r[maxn + 10]/*右儿子*/;struct tree &#123;/*树的结构体*/ int data; tree *lchild, *rchild;&#125;;namespace Lonely &#123; inline int read() &#123; #define in(n) n=read() register int x=0; register char ch = getchar(); for(; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for(; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return x; &#125; inline void write(int x) &#123; #define out(n) write(n) #define outn(n) write(n), putchar('\n') if(x &lt; 0) &#123;putchar('-');x = -x;&#125; if(x &gt;= 10)write(x / 10); putchar(x % 10 + '0'); &#125; tree *ctetree(int i) &#123;/*建树*/ tree *t = NULL; t = new tree(); t -&gt; data = i; if(l[i])t -&gt; lchild = ctetree(l[i]); if(r[i])t -&gt; rchild = ctetree(r[i]); return t; &#125; void pre(tree *root) &#123;/*前序*/ if(root) &#123; out(root -&gt; data), putchar(' '); pre(root -&gt; lchild); pre(root -&gt; rchild); &#125; else return; &#125; void ino(tree *root) &#123;/*中序*/ if(root) &#123; ino(root -&gt; lchild); out(root -&gt; data), putchar(' '); ino(root -&gt; rchild); &#125; else return; &#125; void pos(tree *root) &#123;/*后序*/ if(root) &#123; pos(root -&gt; lchild); pos(root -&gt; rchild); out(root -&gt; data), putchar(' '); &#125; else return; &#125; int Main() &#123;/*分别输出*/ in(n); for(int i = 1; i &lt;= n; i++) in(l[i]), in(r[i]); tree *root = ctetree(1); pre(root); putchar('\n'); ino(root); putchar('\n'); pos(root); return 0; &#125;&#125;int main() &#123; return Lonely::Main();&#125; $\color{gray}{\mathcal{By}}$ $\color{gray}{\mathfrak{NULL}}$]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ P1013 [JSOI2008]球形空间产生器]]></title>
    <url>%2F2019%2F02%2F05%2FP1923-%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[题目描述有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。 输入格式第一行是一个整数n。 接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。 输出格式有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后3位。 数据保证有解。你的答案必须和标准输出一模一样才能够得分。 样例输入123420.0 0.0-1.0 1.01.0 0.0 样例输出10.500 1.500 数据规模与约定对于40%的数据，$1&lt;=n&lt;=3$。 对于100%的数据，$1&lt;=n&lt;=10$。 1、 球心：到球面上任意一点距离都相等的点。 2、 距离：设两个n为空间上的点A, B的坐标为$(a_1,a_2,…,a_n),(b_1,b_2,…,b_n)，则AB的距离定义为： $dist=sqrt((a_1−b_1)^2+(a_2−b_2)^2+…+(a_n−b_n)^2)$ 数据中所有数据绝对值小于 10000 。 因为是一个球，所以每个点到球心的距离都相等， 我们设这个半径为R，球心坐标为$O(x_1,x_2,….,x_n)$; 那么对于每一个点$P(ai1,ai2,…,ain)$：我们易得 $sqrt ( ( ai1 - x1 ) ^ 2 + ( ai2 - x2 ) ^ 2 + … + ( ain - xn ) ^2 ) = R$; 考虑构造方程组 将上式两侧平方再展开，得 $-2 ( ai1 x1 + ai2 x2 + … + ain * xn )+( ai1 ^ 2 + ai2 ^ 2 + … + ain ^ 2 )+( x1 ^ 2 + x2 ^ 2 + … + xn ^ 2 )$ = $R ^ 2$; 给出n+1个点，n个点就可以构造该方程组，那多给的一个点是用来（设选第一个点为这个点） 消掉重复出现的部分$( x1 ^ 2 + x2 ^ 2 + … + xn ^ 2 )$和$R ^ 2$， 即令其他所有的点的方程都减掉多的一个点的方程，整理得到其他方程格式为： $2 ( ai1 x1 + ai2 x2 + … + ain * xn )$ =$ ( ai1 ^ 2 + ai2 ^ 2 + … + ain ^ 2 ) - ( a11 ^ 2 + a12 ^ 2 + … + a1n ^ 2 ) - 2 ( a11 x1 + a12 x2 + … + a1n * xn ) $; 右侧是常数，左侧展开就是一个愉快的高斯消元方程组. Code… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;const double eps=1e-8;const int maxn=101;double det;/*Namespace's template*/template&lt;class type&gt;type _max(type a, type b)&#123;return a &gt; b ? a : b;&#125;template&lt;class type&gt;type _min(type a, type b)&#123;return a &lt; b ? a : b;&#125;template&lt;class type&gt;type _abs(type a)&#123;return a &lt; 0 ? -a : a;&#125;template&lt;class type&gt;type _gcd(type a, type b)&#123;return (!b) ? a : gcd(b, a % b);&#125;template&lt;class type&gt;type _mod(type a, type p)&#123;if(a &gt;= 0 &amp;&amp; a &lt; p)return a;a %= p;if(a &lt; 0)a += p;return a;&#125;template&lt;class type&gt;type _qpow(type a, type b, type p)&#123;type ans = 1;for(; b; b &gt;&gt;= 1, a = _mod(a * a, p))if(b &amp; 1)ans = _mod(ans * a, p);return ans;&#125;char buf[1&lt;&lt;21],*p1=buf,*p2=buf;inline int getc() &#123; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++;&#125;inline int r() &#123; register int x = 0; register char ch = getchar(); for(; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for(; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return x;&#125;inline double r_db () &#123; double s = 0.0; int f = 1; char c = getchar(); while (c &lt; '0' || c &gt; '9') &#123;if (c == '-') f = -1;c = getchar();&#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123;s = s * 10 + (c ^ 48);c = getchar();&#125; if (c == '.') &#123;int k = 10;c = getchar();while (c &gt;= '0' &amp;&amp; c &lt;= '9') &#123;s += (double)(c ^ 48) / k;k *= 10;c = getchar();&#125;&#125; return s;&#125;/*end template*/inline int Gauss(double a[][maxn],bool l[],double ans[],const int &amp;n,const int &amp;m)&#123; int res=0,r=0; for(int i=0;i&lt;n;++i) l[i]=false; for(int i=0;i&lt;n;++i)&#123; for(int j=r;j&lt;m;++j) if(fabs(a[j][i])&gt;eps)&#123; for(int k=i;k&lt;=n;++k) std::swap(a[j][k],a[r][k]); break; &#125; if(fabs(a[r][i])&lt;eps)&#123; ++res; continue; &#125; for(int j=0;j&lt;m;++j) if(j!=r &amp;&amp; fabs(a[j][i])&gt;eps)&#123; double tmp=a[j][i]/a[r][i]; for(int k=i;k&lt;=n;++k) a[j][k]-=tmp*a[r][k]; &#125; l[i]=true,++r; &#125; det=1; for(int i=0;i&lt;n;++i) det*=a[i][i]; //检查是否无解 for(int i=n-res;i&lt;m;++i)&#123; if(fabs(a[i][n])&gt;eps) return -1; &#125; for(int i=0;i&lt;n;++i)&#123; if(l[i])//不是自由变元 for(int j=0;j&lt;n;++j) if(fabs(a[j][i])&gt;eps) ans[i]=a[j][n]/a[j][i]; &#125; return res;//返回自由变元数&#125;int main() &#123; double a[maxn][maxn]; bool l[maxn]; double ans[maxn]; double arr[maxn]; double brr[maxn]; int n,m,res; memset(a,0,sizeof(a)); n = r(); m=n; for(int i=0;i&lt;n;++i) scanf("%lf", &amp;arr[i]); for(int i=0;i&lt;n;++i)&#123; for(int j=0;j&lt;n;++j) scanf("%lf", &amp;brr[j]); for(int j=0;j&lt;n;++j) a[i][j]=2*(brr[j]-arr[j]); for(int j=0;j&lt;n;++j) a[i][n]+=(brr[j]*brr[j]-arr[j]*arr[j]); for(int j=0;j&lt;n;++j) arr[j]=brr[j]; &#125; res=Gauss(a,l,ans,n,m); for(int i=0;i&lt;n;++i)// if(i==n-1) printf("%.3lf\n",ans[i]); else printf("%.3lf ",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈和队列]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1. 栈 什么是栈？ 栈是限定仅在表头进行插入和删除操作的线性表。栈分为顺序栈和链式栈。 栈的实现 顺序栈 12345678910111213int stack[100], sz = 0;void push(int x) &#123;//入栈 stack[++sz] = x;&#125;void pop() &#123;//出栈 sz--;&#125;int top() &#123;//返回栈顶元素 return stack[sz];&#125;bool empty() &#123;//判断栈是否为空 return sz &gt;= 0 ? true : false;&#125; 链式栈 123456789101112131415161718192021222324252627282930313233343536373839//链式栈只会写一点class list&#123;public: list *head; list *tail; list *next; int num; list()&#123; head=tail=next=NULL; &#125; virtual void push(int x)=0; virtual int pop()=0;&#125;;class stack:public list&#123;public: void push(int x); int pop();&#125;;void stack::push(int x)&#123; list *noww; noww=new stack; if(!noww) return ; noww-&gt;num=x; if(head) noww-&gt;next=head; head=noww; if(!tail) tail=head;&#125;int stack::pop()&#123; int x; list *p; if(!head) return 0; x=head-&gt;num; p=head; head=head-&gt;next; delete p; return x;&#125; 2. 队列 什么是队列？ 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。 队列的实现 12345678910111213141516int queue[100], head = 0, tail = 0;void push(int x) &#123; queue[++tail] = x;&#125;void pop() &#123; head++;&#125;int front() &#123; return queue[head];&#125;int size() &#123; return tail - head;&#125;bool empty() &#123; return head &gt; tail ? true : false;&#125; 实际上队列也可以用链表实现，这里不再赘述。 3. STL实现栈和队列1234567891011121314151617//栈常用操作#include &lt;stack&gt;stack &lt;int&gt; s;s.push(1);s.pop();s.top();s.empty();s.size();//队列常用操作#include &lt;queue&gt;queue &lt;int&gt; q;q.push(1);q.pop();q.front();q.back();q.empty();q.size(); $\color{gray}{\mathcal{By}}$ $\color{gray}{\mathfrak{NULL}}$]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆和二叉树]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%A0%86%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。一棵深度为k，且有2^k-1个节点的二叉树，称为满二叉树。这种树的特点是每一层上的节点数都是最大节点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则此二叉树为完全二叉树。具有n个节点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2^k-1个叶子节点，至多有2^k-1个节点。 一般二叉树性质 在非空二叉树的i层上，至多有2^i-1个节点(i&gt;=1)。 在深度为K的二叉树上最多有2^k-1个结点（k&gt;=1)。 对于任何一棵非空的二叉树,如果叶节点个数为n0，度数为2的节点个数为n2，则有: n0 = n2 + 1 完全二叉树性质 具有n的结点的完全二叉树的深度为log2n+1. 如果有一颗有n个节点的完全二叉树的节点按层次序编号，对任一层的节点i（1&lt;=i&lt;=n）有 1.如果i=1，则节点是二叉树的根，无双亲，如果i&gt;1，则其双亲节点为[i/2]，向下取整 2.如果2i&gt;n那么节点i没有左孩子，否则其左孩子为2i 3.如果2i+1&gt;n那么节点没有右孩子，否则右孩子为2i+1 二叉树遍历 前序遍历 先访问根结点，再先序遍历左子树，最后再先序遍历右子树即根—左—右。 1234567void PreOrderTraverse(BiTree t) &#123; if(t != NULL) &#123; printf("%c ", t-&gt;data); PreOrderTraverse(t -&gt; lchild); PreOrderTraverse(t -&gt; rchild); &#125;&#125; 中序遍历 先中序遍历左子树，然后再访问根结点，最后再中序遍历右子树即左—根—右。 1234567void InOrderTraverse(BiTree t) &#123; if(t != NULL) &#123; InOrderTraverse(t -&gt; lchild); printf("%c ", t-&gt;data); InOrderTraverse(t -&gt; rchild); &#125; &#125; 后序遍历 先后序遍历左子树，然后再后序遍历右子树，最后再访问根结点即左—右—根。 1234567void PostOrderTraverse(BiTree t) &#123; if(t != NULL) &#123; PostOrderTraverse(t -&gt; lchild); PostOrderTraverse(t -&gt; rchild); printf("%c ", t-&gt;data); &#125;&#125; 建树 1234567891011121314151617181920212223typedef struct node &#123; struct node *lchild; struct node *rchild; char data; &#125;BiTreeNode, *BiTree;void createBiTree(BiTree &amp;T, char array[]) &#123; char c; c = array[N]; N++; if('#' == c) T = NULL; else &#123; if(T == NULL) return ; else &#123; T = new BiTreeNode; T -&gt; data = c; createBiTree(T -&gt; lchild, array); createBiTree(T-&gt;rchild, array); &#125; &#125;&#125; 例题 YZOJ P1196 Postorder Traversal 大体思路：因为后序遍历的最后一个字母就是根结点，在中序遍历中根结点的左边就是左子树，右边就是右子树，所以可以计算出左子树的结点总数和右子树的节点总数，再用结点的总数将后序遍历中的结点分开，分开后就是两个子树的后序遍历。 代码： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;string in, after;void search(string in,string after) &#123; int len = in.size(); if(len &lt;= 0) return; char ch = after[len - 1]; cout &lt;&lt; ch; int k = in.find(ch); search(in.substr(0, k), after.substr(0, k)); search(in.substr(k + 1), after.substr(k, len - 1 - k));&#125;int main() &#123; cin &gt;&gt; in &gt;&gt; after; search(in, after); return 0;&#125; 堆是一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 堆中某个节点的值总是不大于或不小于其父节点的值； 堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 堆主要的作用是用来实现优先队列。 堆分为大根堆和小根堆，下面用小根堆做示例。 插入操作 手写实现：123456void push(int x) &#123;//swap是交换两个数的值 q[++sz] = x; int pos = sz; while(pos &gt; 1 &amp;&amp; q[pos &gt;&gt; 1] &gt; q[pos]) swap(q[pos], q[pos &gt;&gt; 1]), pos = pos &gt;&gt; 1;&#125; 删除操作 手写实现:123456789101112void pop() &#123;//swap是交换两个数的值 int rt = q[sz--], pos = 1; q[pos] = rt; while(true) &#123; int lv = (pos &lt;&lt; 1) &gt; sz ? inf : q[pos &lt;&lt; 1]; int rv = (pos &lt;&lt; 1 | 1) &gt; sz ? inf : q[pos &lt;&lt; 1 | 1]; int v = min(lv, rv), nt = lv &lt; rv ? (pos &lt;&lt; 1) : (pos &lt;&lt; 1 | 1); if(q[pos] &gt; v) swap(q[pos], q[nt]), pos = nt; else break; &#125;&#125; 其他操作 手写实现： 1234567891011int top() &#123;//返回队首元素 return q[1];&#125;int size() &#123;//返回队列大小 return sz;&#125;bool empty() &#123; return sz == 0 ? true : false;&#125; STL实现优先队列12345678empty()//如果队列为空，则返回真pop()//删除对顶元素，删除第一个元素push()//加入一个元素size()//返回优先队列中拥有的元素个数top()//返回优先队列对顶元素，返回优先队列中有最高优先级的元素//在默认的优先队列中，优先级高的先出队。在默认的int型中先出队的为较大的数。//需要头文件#include &lt;queue&gt; 实际上你可以去YZOJ里的AAS里有一个pb_ds库的介绍，可以实现优先队列，速度接近手写。例题 YZOJ P2704 [NOIP 2016 四校联训 Round 4]打败黑熊 大体思路：维护一个小根堆，每个守卫机关相当于向堆中加入一个数，每个审判机关相当于删除堆中最小值，直到堆中的元素个数小于上限。最后直接把堆中所有的数加起来。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//顺便演示一下pb_ds中的priority_queue#include &lt;cstdio&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;//注意要加这个头文件using namespace std;__gnu_pbds::priority_queue&lt;int,greater&lt;int&gt; &gt; q;//声明方式 int n, m;char st[6];inline int read() &#123;//快读 #define in(n) n=read() register int x = 0; register char ch = getchar(); for(; ch &lt; '0' || ch &gt; '9'; ch = getchar()); for(; ch &gt;= '0' &amp;&amp; ch &lt;= '9'; ch = getchar()) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (ch ^ 48); return x;&#125;int main() &#123; in(n), in(m); for(int i = 1, t; i &lt;= n; i++) &#123; scanf("%s", &amp;st); in(t); if(st[0] == 'd') &#123; q.push(t); continue; &#125; if(t &lt;= 0) &#123; puts("Rabbit can not beat bear."); return 0; &#125; while(q.size() &gt;= t) q.pop(); &#125; int ans = 0, sz = 0; while(!q.empty()) &#123; ans += q.top(); sz++; q.pop(); &#125; if(sz &gt;= m) printf("%d\n", ans); else &#123; puts("Rabbit can not beat bear."); return 0; &#125; return 0;&#125; $\color{gray}{\mathcal{By}}$ $\color{gray}{\mathfrak{NULL}}$]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YZOJ P1299 [NOIP福建夏令营]金字塔]]></title>
    <url>%2F2018%2F11%2F17%2FYZOJ-P1299-NOIP%E7%A6%8F%E5%BB%BA%E5%A4%8F%E4%BB%A4%E8%90%A5-%E9%87%91%E5%AD%97%E5%A1%94%2F</url>
    <content type="text"><![CDATA[题目描述小X来到一个雄奇的金字塔挖宝，但是这是一座被诅咒的金字塔，小X必须马上逃离这里，否则小X就会被埋在金字塔里，但他不希望此行落空。 现在小X面前有$N+1$种财宝，每种财宝都有一个价值。第一种财宝重量为0，第二种财宝重量为1，总之第I种财宝重量为$I-1$。现在小X希望拿走$N+M$个物品，但是这$M+N$个物品总重量不能超过N。小X希望能获得最大的价值。你能帮帮他吗？ 由于金字塔跟小X一样牛，所以每种财宝无限个。 输入格式第一行两个正整数$N$，$M$ 第二行$N+1$个整数，第$I$个整数代表了第I种财宝的价值 输出格式一个数，表示最大利润。 样例输入125 34 7 2 5 -3 6 样例输出147 数据规模与约定10%满足$N$,$M&lt;=10$ 40%满足$N$,$M&lt;=100$ 100%满足$N$,$M&lt;=3000$ $abs(财宝价值)&lt;=1000$ 这就是一道背包的应用题。你们也可以学习kyz的做法（毕竟他的做法貌似比我的快，空间用的比我小），在这里讲一下我的一种做法。 这是一个比较特殊的动态规划，首先要注意到因为要取到$N+M$个，所以我们可以知道每一次至少要拿走$M+N$件0号物品，所以我们的初始化就是这样。 12for(i=0;i&lt;=n;i++) f[i]=(n+m)*a[0]; 对于这样的完全背包问题，我们需要找到一个动态规划转移方程。$f[i]$表示$i$的体积下最多得到的价值，$f[j]+a[i]-a[0]$是从j空间转移而来，所以$f[j]+a[i]-a[0]$中$-a[0]$的原因是：我们模拟出来在执行之前，全部都装满了0号物品，所以我们在转移的时候，需要取出一个0号物品，再塞进去一个$i$号物品。 1f[i+j]=max(f[j]+a[i]-a[0],f[i+j]); 代码： 1234567891011121314#include &lt;cstdio&gt;#define re register//我没用快读模板是因为有负数，所以我就用了scanfint n,m;int a[3001],f[3001]=&#123;0&#125;;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(re int i=0;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(re int i=0;i&lt;=n;i++) f[i]=(n+m)*a[0]; //初始化 for(re int i=1;i&lt;=n;i++) for(re int j=0;j&lt;=n-i;j++) f[i+j]=max(f[j]+a[i]-a[0],f[i+j]); //动态转移方程 return !printf("%d\n",f[n]);&#125; $\color{gray}{\mathfrak{End}}$]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018%2F11%2F10%2FNOIP2018%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今年是我第一次参加NOIP，心情非常的激动。 去试机时，打了个a+b，之后就在玩扫雷。 比赛当天，早上在家A了一道dp题，下午去比赛。 T1：这不是一道大水题吗？ 5-10min完成。 T2：这也很水啊，一道普普通通的模拟。 15-30min完成（主要是在弄大数据） T3：考场上觉得这又是一道模拟，然而我想的太简单了。 打了个暴力。 后来知道这道正解是dp。。。 T4：没时间了，T3耗太久了。 直接输样例 预计：100+100+50+10=260 实际：70+100+10+4=184 完蛋了T1这么水的题我都没A， 只能回去搞文化课了。。。]]></content>
      <tags>
        <tag>NOIP游记</tag>
      </tags>
  </entry>
</search>
